// Grammar for Asteroid written in EBNF format.
// (c) Lutz Hamel, University of Rhode Island

prog
  : stmt_list

stmt_list
  : stmt*

stmt
  : '.' // NOOP
  | LOAD STRING '.'?
  | GLOBAL id_list '.'?
  | NONLOCAL id_list '.'?
  | ASSERT exp '.'?
  | STRUCTURE ID WITH struct_stmts END
  | TRAIT ID WITH trait_stmts END
  | LET pattern '=' exp '.'?
  | LOOP DO? stmt_list END
  | FOR pattern IN exp DO stmt_list END
  | WHILE exp DO stmt_list END
  | REPEAT DO? stmt_list UNTIL exp '.'?
  | IF exp DO stmt_list (ELIF exp DO stmt_list)* (ELSE DO? stmt_list)? END
  | MATCH exp WITH? (CASE pattern DO stmt_list)+ (OTHERWISE DO? stmt_list)? END
  | TRY DO? stmt_list (CATCH pattern DO stmt_list)+ END
  | THROW exp '.'?
  | BREAK '.'?
  | RETURN exp? '.'?
  | function_def
  | call '.'?

function_def
  : FUNCTION ID body_defs END

data_stmt
  : DATA ID ('=' exp)? '.'?

trait_stmt
  : TRAIT ID .'?'

struct_stmts
  : (trait_stmt)* (data_stmt)* (function_def '.'?)* '.'*

trait_stmts
  : (data_stmt)* (function_def '.'?)* '.'*

id_list
  : ID (',' ID)*

body_defs
  : WITH pattern DO stmt_list (ORWITH pattern DO stmt_list)*

// NOTE: There is no syntactic difference between a pattern
// and an expression. We introduce the 'pattern' nonterminal
// to highlight the SEMANTIC difference between patterns and
// expressions.

pattern
  : exp

exp
  : quote_exp

quote_exp
  : QUOTE head_tail
  | PATTERN WITH head_tail
  | head_tail

head_tail
  : compound ('|' exp)?

compound
  : logic_exp0
      (
         (IS pattern) |
         (IN exp) |               // exp has to be a list
         (TO exp (STEP exp)?) |   // list comprehension
      )?

// operators with their precedences
logic_exp0
  : logic_exp1 (OR logic_exp1)*

logic_exp1
  : rel_exp0 (AND rel_exp0)*

rel_exp0
  : rel_exp1 (('==' | '=/=' ) rel_exp1)*

rel_exp1
  : arith_exp0 (('<=' | '<'  | '>=' | '>') arith_exp0)*

arith_exp0
  : arith_exp1 (('+' | '-') arith_exp1)*

arith_exp1
  : conditional (('*' | '/') conditional)*

conditional
  : call
      (
         (CMATCH exp) |   // CMATCH == '%'IF
         (OTHERWISE exp) |
         (IF exp (ELSE exp)?)
      )?

call
  : index index*

index
  : primary ('@' primary)*

primary
  : INTEGER
  | REAL
  | STRING
  | TRUE
  | FALSE
  | NONE
  | ID (':' exp)?  // named patterns when ': exp' exists
  | '*' ID         // "dereference" a variable during pattern matching
  | NOT call
  | MINUS call
  | ESCAPE STRING
  | EVAL exp
  | '(' tuple_stuff ')' // tuple/parenthesized expr
  | '[' list_stuff ']'  // list or list access
  | function_const
  | TYPECLASS           // TYPECLASS == '%'<typename>

tuple_stuff
  : exp (',' exp?)*
  | empty

list_stuff
  : exp (',' exp)*
  | empty

function_const
  : LAMBDA body_defs
